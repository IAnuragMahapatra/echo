#!/usr/bin/env python
"""
Crypto Narrative Pulse Tracker - Live Showcase

This showcase uses:
1. REAL price data from CoinGecko API
2. LLM-generated fake social media posts (mimicking X/Twitter API)
3. Real sentiment analysis and pulse score calculation
4. Live Telegram alerts

This demonstrates the full system as it would work in production,
but with synthetic social media data generated by an LLM.

Usage:
  python showcase_live.py                    # Run with default coin (MEME)
  python showcase_live.py --coin PEPE        # Track a different coin
  python showcase_live.py --no-telegram      # Run without Telegram alerts
  python showcase_live.py --rounds 10        # Run 10 rounds of analysis

Requirements:
  - Ollama running locally (or other LLM endpoint)
  - CoinGecko API key in .env (optional, falls back to free tier)
  - Telegram bot token in .env (optional)
"""

import asyncio
import json
import os
import random
import sys
import time
from datetime import datetime, timezone
from typing import Optional

# Fix Windows console encoding
if sys.platform == "win32":
    try:
        sys.stdout.reconfigure(encoding="utf-8", errors="replace")
    except Exception:
        pass

sys.path.insert(0, ".")

from dotenv import load_dotenv

load_dotenv()

# Mock pathway for Windows
from unittest.mock import MagicMock

mock_pw = MagicMock()
mock_pw.Schema = type("Schema", (), {})
sys.modules["pathway"] = mock_pw


from connectors.price_fetcher import PriceFetcher
from transforms.divergence import detect_divergence
from transforms.pulse_score import PulseScoreCalculator
from transforms.sentiment import SentimentAnalyzer

# =============================================================================
# LLM-BASED SOCIAL MEDIA POST GENERATOR
# =============================================================================


class LLMPostGenerator:
    """
    Generates realistic fake social media posts using an LLM.
    Mimics what we'd get from the X (Twitter) API.
    """

    def __init__(
        self, model: str = "mistral", ollama_host: str = "http://localhost:11434"
    ):
        self.model = model
        self.ollama_host = ollama_host
        self.enabled = True

        # Test connection
        try:
            import requests

            response = requests.get(f"{ollama_host}/api/tags", timeout=5)
            if response.status_code == 200:
                print(f"  âœ… LLM connected: {ollama_host}")
            else:
                print("  âš ï¸ LLM connection issue, using fallback posts")
                self.enabled = False
        except Exception as e:
            print(f"  âš ï¸ LLM not available ({e}), using fallback posts")
            self.enabled = False

    def generate_posts(
        self,
        coin_symbol: str,
        current_price: float,
        price_change_24h: float,
        sentiment_bias: str = "mixed",
        count: int = 5,
    ) -> list[dict]:
        """
        Generate realistic social media posts about a cryptocurrency.

        Args:
            coin_symbol: The coin being discussed (e.g., "MEME", "PEPE")
            current_price: Current price in USD
            price_change_24h: 24h price change percentage
            sentiment_bias: "bullish", "bearish", or "mixed"
            count: Number of posts to generate

        Returns:
            List of post dictionaries mimicking X API response
        """
        if not self.enabled:
            return self._generate_fallback_posts(coin_symbol, sentiment_bias, count)

        prompt = self._build_prompt(
            coin_symbol, current_price, price_change_24h, sentiment_bias, count
        )

        try:
            import requests

            response = requests.post(
                f"{self.ollama_host}/api/generate",
                json={
                    "model": self.model,
                    "prompt": prompt,
                    "stream": False,
                    "options": {"temperature": 0.9, "num_predict": 1000},
                },
                timeout=30,
            )

            if response.status_code == 200:
                result = response.json()
                return self._parse_llm_response(
                    result.get("response", ""), coin_symbol, count
                )
            else:
                return self._generate_fallback_posts(coin_symbol, sentiment_bias, count)

        except Exception as e:
            print(f"    âš ï¸ LLM generation failed: {e}")
            return self._generate_fallback_posts(coin_symbol, sentiment_bias, count)

    def _build_prompt(
        self,
        coin_symbol: str,
        current_price: float,
        price_change_24h: float,
        sentiment_bias: str,
        count: int,
    ) -> str:
        """Build the prompt for the LLM."""

        price_context = "up" if price_change_24h > 0 else "down"

        sentiment_instruction = {
            "bullish": "Make most posts optimistic and excited about the coin.",
            "bearish": "Make most posts worried, fearful, or negative about the coin.",
            "mixed": "Mix of bullish, bearish, and neutral opinions.",
        }.get(sentiment_bias, "Mix of opinions.")

        return f"""Generate {count} realistic crypto Twitter/X posts about ${coin_symbol}.

Current context:
- Price: ${current_price:.6f}
- 24h change: {price_change_24h:+.2f}% ({price_context})
- Sentiment bias: {sentiment_bias}

{sentiment_instruction}

Rules:
- Write like real crypto Twitter users (casual, emoji-heavy, slang)
- Include common crypto phrases: "LFG", "to the moon", "WAGMI", "ngmi", "rug", "pump", "dump", "dip", "hodl", "ape in"
- Some posts from "influencers" (more followers), some from regular users
- Vary post length (short tweets to longer threads)
- Include some price predictions, some memes, some analysis
- Make it feel authentic - typos are okay, enthusiasm is key

Output format (JSON array):
[
  {{"text": "post content here", "author": "username", "followers": 1234, "is_influencer": false}},
  ...
]

Generate exactly {count} posts as a JSON array:"""

    def _parse_llm_response(
        self, response: str, coin_symbol: str, expected_count: int
    ) -> list[dict]:
        """Parse the LLM response into post dictionaries."""
        try:
            # Try to extract JSON from response
            start = response.find("[")
            end = response.rfind("]") + 1
            if start >= 0 and end > start:
                json_str = response[start:end]
                posts = json.loads(json_str)

                # Convert to our format
                result = []
                for post in posts[:expected_count]:
                    result.append(
                        {
                            "text": post.get("text", ""),
                            "author_id": post.get(
                                "author", f"user_{random.randint(1000, 9999)}"
                            ),
                            "author_followers": post.get(
                                "followers", random.randint(100, 50000)
                            ),
                            "is_influencer": post.get("is_influencer", False),
                            "timestamp": datetime.now(timezone.utc)
                            .isoformat()
                            .replace("+00:00", "Z"),
                            "coin_symbol": coin_symbol,
                            "source": "llm_generated",
                        }
                    )
                return result
        except json.JSONDecodeError:
            pass

        # Fallback if parsing fails
        return self._generate_fallback_posts(coin_symbol, "mixed", expected_count)

    def _generate_fallback_posts(
        self, coin_symbol: str, sentiment_bias: str, count: int
    ) -> list[dict]:
        """Generate fallback posts without LLM."""

        bullish_posts = [
            f"${coin_symbol} looking absolutely bullish rn ðŸš€ðŸš€ LFG!",
            f"Just aped into ${coin_symbol}, this is gonna be huge ðŸ’ŽðŸ™Œ",
            f"${coin_symbol} to the moon! Who's with me? ðŸŒ™",
            f"The chart on ${coin_symbol} is looking insane, breakout incoming ðŸ“ˆ",
            f"Loaded up more ${coin_symbol} on this dip, ez money ðŸ’°",
            f"${coin_symbol} community is unmatched, WAGMI ðŸ”¥",
            f"If you're not holding ${coin_symbol} you're ngmi fr fr",
            f"${coin_symbol} about to 10x from here, mark my words ðŸŽ¯",
        ]

        bearish_posts = [
            f"${coin_symbol} looking weak, might dump more ðŸ“‰",
            f"Getting worried about ${coin_symbol}, anyone else?",
            f"${coin_symbol} giving me rug vibes ngl ðŸ˜¬",
            f"Sold my ${coin_symbol} bag, taking profits while I can",
            f"${coin_symbol} volume is dead, not a good sign",
            f"This ${coin_symbol} pump feels fake, be careful out there",
            f"${coin_symbol} holders in shambles rn ðŸ’€",
            f"Might be time to cut losses on ${coin_symbol}...",
        ]

        neutral_posts = [
            f"What do you guys think about ${coin_symbol}? Thinking of buying",
            f"${coin_symbol} consolidating, waiting for a clear direction",
            f"Anyone got alpha on ${coin_symbol}? DM me",
            f"${coin_symbol} chart looking interesting, need more data",
            f"Watching ${coin_symbol} closely, could go either way",
        ]

        # Select posts based on sentiment bias
        if sentiment_bias == "bullish":
            pool = bullish_posts * 3 + neutral_posts
        elif sentiment_bias == "bearish":
            pool = bearish_posts * 3 + neutral_posts
        else:
            pool = bullish_posts + bearish_posts + neutral_posts

        result = []
        for _ in range(count):
            text = random.choice(pool)
            is_influencer = random.random() < 0.2
            followers = (
                random.randint(50000, 500000)
                if is_influencer
                else random.randint(100, 10000)
            )

            result.append(
                {
                    "text": text,
                    "author_id": f"user_{random.randint(1000, 9999)}",
                    "author_followers": followers,
                    "is_influencer": is_influencer,
                    "timestamp": datetime.now(timezone.utc)
                    .isoformat()
                    .replace("+00:00", "Z"),
                    "coin_symbol": coin_symbol,
                    "source": "fallback",
                }
            )

        return result


# =============================================================================
# TELEGRAM BOT
# =============================================================================


class LiveShowcaseBot:
    """Telegram bot for live showcase alerts."""

    def __init__(self, token: str, channel_id: str, coin_symbol: str):
        self.token = token
        self.channel_id = channel_id
        self.coin = coin_symbol
        self.bot = None
        self.enabled = True
        self._last_alert_score: Optional[float] = None

        try:
            from telegram import Bot

            self.bot = Bot(token=token)
            print(f"  âœ… Telegram bot initialized for {channel_id}")
        except Exception as e:
            print(f"  âš ï¸ Telegram bot failed: {e}")
            self.enabled = False

    async def send_message(self, text: str) -> bool:
        if not self.enabled or not self.bot:
            return False
        try:
            await self.bot.send_message(
                chat_id=self.channel_id,
                text=text,
                parse_mode="Markdown",
            )
            return True
        except Exception as e:
            print(f"  âš ï¸ Telegram send failed: {e}")
            return False

    async def send_alert(
        self,
        score: float,
        price: float,
        price_change: float,
        phrases: list[str],
        divergence: str,
        post_count: int,
    ) -> bool:
        """Send a momentum alert."""
        if not self.enabled:
            return False

        should_alert = False
        if score >= 7.0:
            if self._last_alert_score is None or self._last_alert_score < 7.0:
                should_alert = True
                emoji = "ðŸš€"
                signal = "High Momentum"
                meaning = "Strong bullish sentiment detected! Social buzz is elevated and community is excited."
        elif score <= 3.0:
            if self._last_alert_score is None or self._last_alert_score > 3.0:
                should_alert = True
                emoji = "â„ï¸"
                signal = "Low Momentum"
                meaning = "Sentiment is cooling off. Community interest appears to be declining."
        else:
            self._last_alert_score = score
            return False

        if not should_alert:
            return False

        # Divergence warning
        div_warning = ""
        if divergence != "aligned":
            div_text = "Bearish" if divergence == "bearish_divergence" else "Bullish"
            div_warning = f"\n\nâš ï¸ *{div_text} Divergence Detected*\nPrice and sentiment moving in opposite directions!"

        phrases_str = ", ".join(phrases[:5]) if phrases else "None detected"
        price_emoji = "ðŸ“ˆ" if price_change > 0 else "ðŸ“‰"

        message = f"""{emoji} *{signal} Alert: ${self.coin}*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ðŸ’° *Live Price:* ${price:.6f} ({price_change:+.2f}% 24h) {price_emoji}
ðŸ“Š *Pulse Score:* {score:.1f}/10
ðŸ“ *Posts Analyzed:* {post_count}

*What this means:*
{meaning}

ðŸ”¥ *Trending phrases:* {phrases_str}{div_warning}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
_Live showcase using real CoinGecko data + LLM-generated posts_
âš ï¸ _Not financial advice - always DYOR!_"""

        result = await self.send_message(message)
        if result:
            self._last_alert_score = score
        return result

    async def send_summary(self, rounds: list[dict], coin: str) -> bool:
        """Send final summary."""
        if not self.enabled:
            return False

        avg_score = sum(r["pulse_score"] for r in rounds) / len(rounds)
        avg_price = sum(r["price"] for r in rounds) / len(rounds)
        total_posts = sum(r["post_count"] for r in rounds)

        # Interpretation
        if avg_score >= 7:
            meaning = (
                "Strong bullish momentum overall! High community excitement detected."
            )
        elif avg_score <= 3:
            meaning = "Low momentum detected. Community sentiment was mostly negative or indifferent."
        else:
            meaning = "Mixed signals. Sentiment varied throughout the showcase."

        message = f"""ðŸ“Š *Live Showcase Complete: ${coin}*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ðŸ“ˆ *Rounds Analyzed:* {len(rounds)}
ðŸ“ *Total Posts:* {total_posts}
ðŸ’° *Avg Price:* ${avg_price:.6f}
ðŸ“Š *Avg Pulse Score:* {avg_score:.1f}/10

*What this means:*
{meaning}

*What we demonstrated:*
âœ… Real CoinGecko price data
âœ… LLM-generated social posts
âœ… Live sentiment analysis
âœ… Real-time pulse scoring

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
_This is how the tracker works in production!_
âš ï¸ _Not financial advice - always DYOR!_"""

        return await self.send_message(message)


# =============================================================================
# MAIN SHOWCASE
# =============================================================================


def print_header(text: str):
    print("\n" + "=" * 70)
    print(f"  {text}")
    print("=" * 70)


def print_subheader(text: str):
    print(f"\n{'â”€' * 60}")
    print(f"  {text}")
    print(f"{'â”€' * 60}")


async def run_live_showcase(
    coin_symbol: str = "MEME",
    rounds: int = 5,
    posts_per_round: int = 8,
    use_telegram: bool = True,
    delay_between_rounds: float = 3.0,
):
    """
    Run the live showcase with real data and LLM-generated posts.

    Args:
        coin_symbol: Cryptocurrency to track
        rounds: Number of analysis rounds
        posts_per_round: Posts to generate per round
        use_telegram: Whether to send Telegram alerts
        delay_between_rounds: Seconds between rounds
    """
    print_header("ðŸ”´ LIVE SHOWCASE - CRYPTO NARRATIVE PULSE TRACKER")

    print(f"""
  This showcase demonstrates the REAL system:
  â€¢ Live price data from CoinGecko API
  â€¢ LLM-generated social media posts (mimicking X/Twitter)
  â€¢ Real sentiment analysis and pulse scoring
  â€¢ Live Telegram alerts (if enabled)

  Tracking: ${coin_symbol}
  Rounds: {rounds}
  Posts per round: {posts_per_round}
    """)

    # Initialize components
    print_subheader("ðŸ”§ Initializing Components")

    # Price fetcher (real CoinGecko data)
    coin_id_map = {
        "MEME": "memecoin-2",  # Correct CoinGecko ID for MEME token
        "PEPE": "pepe",
        "DOGE": "dogecoin",
        "SHIB": "shiba-inu",
        "WIF": "dogwifcoin",
        "BONK": "bonk",
        "BTC": "bitcoin",
        "ETH": "ethereum",
        "SOL": "solana",
        "FLOKI": "floki",
        "TRUMP": "official-trump",
    }
    coin_id = coin_id_map.get(coin_symbol.upper(), coin_symbol.lower())

    price_fetcher = PriceFetcher(coin_id=coin_id, use_simulation=False)
    print(f"  âœ… Price fetcher ready (CoinGecko: {coin_id})")

    # LLM post generator
    ollama_host = os.getenv("OLLAMA_HOST", "http://localhost:11434")
    llm_model = os.getenv("LLM_MODEL", "ollama/mistral").replace("ollama/", "")
    post_generator = LLMPostGenerator(model=llm_model, ollama_host=ollama_host)

    # Sentiment analyzer
    sentiment_analyzer = SentimentAnalyzer()
    print("  âœ… Sentiment analyzer ready")

    # Pulse calculator
    pulse_calculator = PulseScoreCalculator()
    print("  âœ… Pulse calculator ready")

    # Telegram bot
    telegram_bot: Optional[LiveShowcaseBot] = None
    if use_telegram:
        token = os.getenv("TELEGRAM_TOKEN")
        channel_id = os.getenv("TELEGRAM_CHANNEL_ID")
        if token and channel_id:
            telegram_bot = LiveShowcaseBot(token, channel_id, coin_symbol)
            if telegram_bot.enabled:
                await telegram_bot.send_message(
                    f"ðŸ”´ *Live Showcase Starting*\n\n"
                    f"Tracking: *${coin_symbol}*\n"
                    f"Rounds: {rounds}\n\n"
                    f"Using REAL CoinGecko data + LLM-generated posts!\n\n"
                    f"_Watch for live alerts..._"
                )
        else:
            print("  âš ï¸ Telegram credentials not found")

    # Track results
    all_results = []
    last_price = None

    print_header(f"ðŸ“Š STARTING LIVE ANALYSIS: ${coin_symbol}")

    for round_num in range(1, rounds + 1):
        print_subheader(f"ðŸ”„ ROUND {round_num}/{rounds}")

        # 1. Fetch real price with live streaming display
        print("\n  ðŸ’° Fetching live price from CoinGecko...")
        price_fetcher.cache.clear()  # Clear cache to get fresh data
        price_data = price_fetcher.get_price()
        current_price = price_data["price_usd"]

        # Get real 24h change from API if available
        price_change = price_data.get("price_change_24h", 0.0)
        if price_change == 0.0 and last_price:
            # Fallback: calculate from last round
            price_change = ((current_price - last_price) / last_price) * 100

        # Live streaming display
        price_emoji = "ðŸ“ˆ" if price_change > 0 else "ðŸ“‰" if price_change < 0 else "âž¡ï¸"
        print("     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”")
        print(f"     â”‚  ðŸ’° ${coin_symbol} LIVE PRICE        â”‚")
        print(f"     â”‚  ${current_price:<20.8f}       â”‚")
        print(f"     â”‚  {price_change:+.2f}% (24h) {price_emoji}              â”‚")
        print("     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜")

        # 2. Determine sentiment bias based on price action
        if price_change > 3:
            sentiment_bias = "bullish"
        elif price_change < -3:
            sentiment_bias = "bearish"
        else:
            sentiment_bias = "mixed"

        # 3. Generate LLM posts
        print(f"\n  ðŸ¤– Generating {posts_per_round} social media posts (LLM)...")
        posts = post_generator.generate_posts(
            coin_symbol=coin_symbol,
            current_price=current_price,
            price_change_24h=price_change,
            sentiment_bias=sentiment_bias,
            count=posts_per_round,
        )

        # 4. Analyze sentiment
        print("\n  ðŸ“Š Analyzing sentiment...")
        sentiments = []
        influencer_count = 0
        trending_words = {}

        for post in posts:
            sentiment = sentiment_analyzer.analyze(post["text"])
            sentiments.append(sentiment)

            if post.get("is_influencer") or post["author_followers"] > 50000:
                influencer_count += 1

            # Track trending words
            for word in post["text"].lower().split():
                if (
                    len(word) > 3
                    and word.startswith("$")
                    or word
                    in [
                        "moon",
                        "pump",
                        "dump",
                        "rug",
                        "bullish",
                        "bearish",
                        "lfg",
                        "wagmi",
                    ]
                ):
                    trending_words[word] = trending_words.get(word, 0) + 1

            # Display post
            emoji = "ðŸŸ¢" if sentiment > 0.3 else "ðŸ”´" if sentiment < -0.3 else "âšª"
            inf = (
                "â­"
                if post.get("is_influencer") or post["author_followers"] > 50000
                else " "
            )
            source = "ðŸ¤–" if post.get("source") == "llm_generated" else "ðŸ“"
            print(
                f'     {emoji}{inf}{source} "{post["text"][:50]}..." â†’ {sentiment:.2f}'
            )

        # 5. Calculate metrics
        avg_sentiment = sum(sentiments) / len(sentiments)
        influencer_ratio = influencer_count / len(posts)

        # Phrase frequency based on trending words
        phrase_freq = min(30, len(trending_words) * 3 + int(abs(avg_sentiment) * 10))

        # Top trending phrases
        top_phrases = sorted(trending_words.items(), key=lambda x: x[1], reverse=True)[
            :5
        ]
        trending_phrases = [p[0] for p in top_phrases]

        # 6. Detect divergence
        divergence = detect_divergence(avg_sentiment, price_change)

        # 7. Calculate pulse score
        pulse_score = pulse_calculator.calculate(
            sentiment_velocity=avg_sentiment,
            phrase_frequency=phrase_freq,
            influencer_ratio=influencer_ratio,
            divergence_type=divergence,
        )

        # Store result
        result = {
            "round": round_num,
            "price": current_price,
            "price_change": price_change,
            "avg_sentiment": avg_sentiment,
            "pulse_score": pulse_score,
            "divergence": divergence,
            "post_count": len(posts),
            "trending_phrases": trending_phrases,
        }
        all_results.append(result)

        # 8. Display results
        print(f"\n  {'â”€' * 50}")
        print("  ðŸ“Š ROUND RESULTS:")
        print(f"     Avg Sentiment:    {avg_sentiment:>7.3f}")
        print(f"     Influencer Ratio: {influencer_ratio:>7.2f}")
        print(f"     Phrase Frequency: {phrase_freq:>7}")
        print(f"     Divergence:       {divergence}")
        print(f"  {'â”€' * 50}")

        # Visual pulse score
        bar_length = int(pulse_score * 3)
        bar = "â–ˆ" * bar_length + "â–‘" * (30 - bar_length)
        score_emoji = "ðŸŸ¢" if pulse_score >= 7 else "ðŸ”´" if pulse_score <= 3 else "ðŸŸ¡"

        print(f"\n  {score_emoji} PULSE SCORE: {pulse_score:.1f}/10")
        print(f"     [{bar}]")

        # Console alerts
        if pulse_score >= 7:
            print("\n  ðŸš€ðŸš€ðŸš€ HIGH MOMENTUM DETECTED! ðŸš€ðŸš€ðŸš€")
        elif pulse_score <= 3:
            print("\n  â„ï¸â„ï¸â„ï¸ LOW MOMENTUM DETECTED â„ï¸â„ï¸â„ï¸")

        if divergence != "aligned":
            print(f"\n  âš ï¸ DIVERGENCE: {divergence.replace('_', ' ').title()}")

        # 9. Send Telegram alert
        if telegram_bot and telegram_bot.enabled:
            alert_sent = await telegram_bot.send_alert(
                score=pulse_score,
                price=current_price,
                price_change=price_change,
                phrases=trending_phrases,
                divergence=divergence,
                post_count=len(posts),
            )
            if alert_sent:
                print("  ðŸ“¤ Telegram alert sent!")

        # Update last price
        last_price = current_price

        # Delay between rounds
        if round_num < rounds:
            print(f"\n  â³ Next round in {delay_between_rounds}s...")
            time.sleep(delay_between_rounds)

    # Final summary
    print_header("ðŸ“Š LIVE SHOWCASE COMPLETE")

    avg_score = sum(r["pulse_score"] for r in all_results) / len(all_results)
    total_posts = sum(r["post_count"] for r in all_results)

    print(f"\n  ðŸ“ˆ Rounds completed: {len(all_results)}")
    print(f"  ðŸ“ Total posts analyzed: {total_posts}")
    print(f"  ðŸ“Š Average pulse score: {avg_score:.1f}/10")

    # Send Telegram summary
    if telegram_bot and telegram_bot.enabled:
        await telegram_bot.send_summary(all_results, coin_symbol)
        print("\n  ðŸ“¤ Summary sent to Telegram!")

    print("\n" + "=" * 70)
    print("  Showcase complete!")
    print("=" * 70 + "\n")


def main():
    """Main entry point."""
    import argparse

    parser = argparse.ArgumentParser(description="Live Crypto Pulse Showcase")
    parser.add_argument("--coin", default="MEME", help="Coin symbol to track")
    parser.add_argument(
        "--rounds", type=int, default=5, help="Number of analysis rounds"
    )
    parser.add_argument("--posts", type=int, default=8, help="Posts per round")
    parser.add_argument("--no-telegram", action="store_true", help="Disable Telegram")
    parser.add_argument("--delay", type=float, default=3.0, help="Delay between rounds")

    args = parser.parse_args()

    asyncio.run(
        run_live_showcase(
            coin_symbol=args.coin.upper(),
            rounds=args.rounds,
            posts_per_round=args.posts,
            use_telegram=not args.no_telegram,
            delay_between_rounds=args.delay,
        )
    )


if __name__ == "__main__":
    main()
